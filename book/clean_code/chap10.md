# 10장 클래스

✓ 여태 코드 행과 코드 블록 올바로 작성하는 법, 함수 올바로 구현하고 서로 관련 맺는 방식을 공부했다
→ 더 높은 단계까지 신경 쓰지 않으면 깨끗한 코드를 얻기는 어렵다.

### 클래스 체계

➣ 클래스를 정의하는 표준 자바 관례

     ✓ 변수 목록

    - 정적 공개 상수
    - 비공개 변수
        - 정적 비공개 상수
        - 정적 비공개 멤버 변수
        - 정적 비공개 멤버 상수
    - 비공개 인스턴스 변수
        - 비공개 멤버 상수
        - 비공개 멤버 변수

→ 그 다음 공개 함수

✓ 비공개 함수는 자신을 호출하는 공개 함수 직후에 넣는다. 추상화 단계가 순차적이다. 신문 기사 읽듯이 읽는다.

⚡︎캡슐화

✓ 변수와 유틸리티 함수는 가능한 공개하지 않는 편이 낫지만 반드시 숨겨야 한다는 법칙도 없다.

✓ 때로는 protected선언으로 테스트 코드에 접근을 허용하기도 함
→ 테스트에 꼭 필요하면 캡슐화를 풀어버려도 됨. 하지만 최후의 수단이 되어야 하고, 그러기 전에 비공개 상태를 유지할 온갖 방법을 강구한다.

### 클래스는 작아야 한다!

✓ 클래스도 작게가 기본 규칙이다. 얼마나 작아야 하는가?
→ **함수는 행의 수**로 크기를 측정했다면, **클래스는 맡은 책임**을 센다.

✓ 메서드 70개짜리 SuperDashBoard (174p)
→ 메서드 5개로 줄이면? 그래도 책임이 너무 많다.
→ 클래스 이름은 해당 클래스 책임을 기술해야 한다.

✓ 간결한 클래스 이름이 떠오르지 않으면 클래스 크기가 너무 커서 그렇다.
→ 예시로 Processor, Manager, Super등과 같이 모호한 단어는 여러 클래스에 책임 떠안겼다는 증거

✓ 작명이 만일(if), 그리고(and), -(하)며(or), 하지만(but) 없이 25단어 내외로 가능해야 한다.

⚡︎ 단일 책임 원칙

✓ SRP는 클래스나 모듈을 변경할 이유가 단 하나뿐이어야 한다는 원칙이다.

✓ 책임, 즉 변경할 이유를 파악하려 애쓰다 보면 코드를 추상화하기도 쉬워진다.

✓ SRP는 중요하며, 지키기 수월한 개념이지만, 많이 무시당한다.

→ 대부분의 사람들이 '깨끗하고 체계적인 소프트웨어'보다 '돌아가는 소프트웨어'에 집중한다. 문제는 일단 돌아가면 일이 끝났다고 생각한다. '깨끗하고 체계적인 소프트웨어'로 관심사 전환을 안한다.

✓ 큰 서랍 몇 개를 두고 모두 던져 넣을 것인가? 작은 서랍 여러개에 이름이 명확한 컴포넌트를 나눠 넣을 것인가?

✓ 작은 클래스 여러개 쓰자. 돌아가는 부품은 그 수가 비슷하다.

⚡︎ 응집도

✓ 클래스의 메서드가 변수를 더 많이 사용할수록 메서드와 클래스는 응집도가 더 높다. 모든 인스턴스 변수를 메서드마다 모두 사용하는 클래스가 응집도가 가장 높다. 논리적인 단위로 묶는 것.

✓ '함수를 작게, 매개변수 목록을 짧게'라는 전략을 따르다 보면 때때로 몇몇 메서드만이 사용하는 인스턴스 변수가 아주 많아진다. 이는 십중팔구 새로운 클래스로 쪼개야 한다는 신호다.

⚡︎ 응집도를 유지하면 작은 클래스 여럿이 나온다.

✓ 변수가 아주 많은 함수에서 일부를 작은 함수로 빼내려는데, 빼내려는 코드가 큰 함수에 정의된 변수 넷을 사용한다?
→ 인수로 넘겨야 할까?

→ 아니다. 클래스 인스턴스 변수로 승격 -> 인수가 필요없다. 함수를 쪼개기 쉬워진다. -> 응집도가 낮아지는 문제, 몇몇 함수만 사용하는 인스턴스 변수가 점점 더 늘아난다.  ->  클래스로 분리하기.

✓ 181~184 동작원리와 알고리즘은 같다. 후자가 변경 시 고쳐야할 부분이 명확하다.

### 변경하기 쉬운 클래스

✓ 186p Sql클래스
→ update문을 추가한다면?
→ SRP위반 - 변경할 이유가 여러 개
→ 구조적으로도 SRP위반 - 비공개 메서드 - 개선할 잠재적인 여지 시사

✓ 187p 공개 인터페이스를 각각 Sql을 파생하는 클래스로 만듦. 공통으로 사용하는 비공개 메서드는 유틸리티 클래스에 넣음
→ update 문 추가해도 기존 클래스 변경 필요 없음
→ SRP, OCP 지원
→ 새 기능을 수정하거나 기존 기능 변경 시 건드릴 코드가 최소인 시스템
→ 이상적인 시스템이람녀 새 긴으 추가 시 시스템을 확장할 뿐, 기존 코드 변경x

### 변경으로부터 격리

✓ 인터페이스와 추상 클래스를 사용해 구현이 미치는 영향을 격리

✓ 상세한 구현에 의존하는 코드는 테스트가 어렵다.
→ 5분마다 값이 달라지는 API (189p~190p)
→ 인터페이스로 분리 후, 테스트용 클래스 만듦
→ 시스템 요소가 잘 격리되어 있으면(결합도가 낮으면), 각 요소를 이해하기도 더 쉬워진다. 자동으로 DIP따르는 클래스 나옴.

✓ StockExchange는 추상적인 개념을 표현하고 구체적인 사실은 모두 숨긴다.