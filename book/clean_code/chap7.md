[Clean Code](evernote:///view/227999746/s692/4a9709a0-d95c-f276-88a0-b17c590c629b/d01d27a8-3f9f-d2a1-64b0-569a3f5d4565/)

# 7장 오류 처리

- 상당수 코드 기반은 전적으로 오류 처리 코드에 좌우된다
    - 여기저기 흩어진 오류 처리 코드 때문에 실제 코드가 하는 일을 파악하기가 거의 불가능하다는 의미
- 하지만 오류 처리 코드로 인해 프로그램 논리를 이해하기 어려워진다면 깨끗한 코드라 보기도 어려움

### 오류 코드보다 예외를 사용하라

- 논리가 오류 처리 코드와 뒤섞이지 않는다.
- 각 개념을 독립적으로 살펴보고 이해할 수 있다.

### Try-Catch-Finally 문부터 작성하라

- 예외에서 범위를 정의
- 먼저 강제로 예외를 일으키는 테스트 케이스를 작성한 후 테스트를 통과하게 코드를 작성하는 방법을 권장
    - 자연스럽게 try블록의 트랜잭션 범위부터 구현하게 되므로 범위 내에서 트랜잭션 본질을 유지하기 쉬워진다.

### 미확인 예외를 사용하라

- 이전에는 확인된 예외가 멋진 아이디어
- 현재는 몇 가지 장점을 제공하지만, 반드시 필요하지 않다.
- 치르는 비용에 상응하는 이익을 제공하는지?
    - 비용 : OCP위반, 하위 단계에서 코드를 변경하면 상위 단계 메서드 모두 바꾸어야 함
    - throws 경로에 위치하는 모든 함수가 최하위 함수에서 던지는 예외를 알아야 함 -> 캡슐화 박살
- 때로는 유용함. 아주 중요한 라이브러리는 모든 예외 잡아야 한다.
- 의존성이라는 비용이 보통 이익보다 크다.

### 예외에 의미를 제공하라

- 던질 때 전후 상황을 충분히 덧붙인다.
    - 실패한 코드의 의도를 파악하려면 호출 스택만으로 부족
- 오류 메세지에 정보 담아 예외와 함께 던지기
    - 실패한 연산 이름, 유형 언급
    - 로깅 사용 시 충분한 정보

### 호출자를 고려해 예외 클래스를 정의하라

- 오류를 정의할 때 프로그래머에게 가장 중요한 관심사는 오류를 잡아내는 방법이 되어야 한다.
- 감싸는 클래스는 매우 유용
    - 외부 API 감싸기
        - 외부 라이브러리와 프로그램 사이 의존성 크게 줄어듬
        - 나중에 다른 라이브러리로 갈아타도 비용이 적음
        - 감싸기 클래스에서 외부 API를 호출하는 대신 테스트 코드 넣기
- 예외 클래스가 하나만 있어도 충분한 코드 많음
    - 예외 클래스에 포함된 정보로 오류를 구분해도 괜찮은 경우
- 여러 예외 클래스
    - 한 예외는 잡아내고 다른 예외는 무시해도 괜찮은 경우

### 정상 흐름을 정의하라

- 앞의 지침들을 따르다 보면 비즈니스 논리와 오류 처리가 잘 분리된 코드가 나온다. 그러나 그러다 보면 오류 감지가 프로그램 언저리로 밀려난다.
- 예외가 논리를 따라가기 어렵게 만드는 경우(138p)
    - 특수사례패턴
        - 클래스를 만들거나 객체를 조작해 특수 사례를 처리
        - 클라이언트 코드가 예외적인 상황을 처리할 필요가 없어짐

### null을 반환하지 마라

- null을 반환하는 코드는 일거리를 늘릴 뿐만 아니라 호출자에게 문제를 떠넘긴다.
    - 누구 하나라도 null을 빼먹는다면?
    - 어플리케이션 저 아래서 날린 NullPointerException
- Collections.emptyList() 활용한 특수사례 140p

### null을 전달하지 마라

- 반환하는 방식도 나쁘지만 메서드로 null을 전달하는 방식은 더 나쁘다.
- 예외유형을 만들거나 assert문을 활용가능하지만 근본적인 해결책이 되진 못한다
- 애초에 null을 넘기지 못하도록 금지하는 정책이 합리적이다.(인수로 null이 넘어오면 문제가 있는 것)