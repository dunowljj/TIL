# CleanCode
# 8장 경계

✓ 시스템에 들어가는 모든 소프트웨어를 개발하는 경우는 드물다. 때로는 패키지를 사고, 때로는 오픈 소스를 사용한다. 때로는 사내 다른팀이 제공하는 컴포넌트를 사용한다. 어떤 식으로든 이 외부 코드를 우리 코드에 깔끔하게 통합해야만 한다.

###

### 외부 코드 사용하기

✓ 인터페이스 제공자와 인터페이스 사용자 사이 특유의 긴장
→ 제공자는 적용성을 최대한 넓히려고 하지만 사용자는 자신의 요구에 집중하는 인터페이스를 바란다.
→ ex) Map은 확실히 유용하지만 이미 제공되는 딱히 필요하지 않은 기능들이 같이 넘어오는 문제가 생긴다.

✓ Seonsor라는 객체를 담는 Map

```
Map seonsors = new HashMap();
Sensor s = (Sensor)sensors.get(sensorId);
```

- 올바른 유형으로 반환할 책임이 클라이언트에 있음
- 깨끗한 코드라 보기 어렵고 의도가 불분명함

✓ 수정 1

```
Map<String, Sensor> sensors = new HashMap<Sensor>();
...
Sensor s = sensors.get(sensorId);
```

- 제네릭스로 코드 가독성이 높아짐
- 필요하지 않은 기능까지 제공

- 결국 프로그램에서 여기저기 넘길 경우, Map인터페이스가 변할 경우, 수정할 코드가 상당히 많아진다.
- 마틴형은 기존 코드에 Map 너무 많이써서 제네릭스 금지한 시스템도 봤다.

✓ 수정 2

```
public class sensors {
    private Map sensors = new HashMap();

    public Sensor getById(String id){
        return (Sensor) sensors.get(id);
    }

//이하 생략
}
```

- 경계 인터페이스인 Map을 Sensors 안으로 숨긴다.
- Sensors 사용자는 제네릭스가 사용되었는지 여부에 신경 쓸 필요가 없다. 제레닉스 사용 여부를 Sensors 안에서 결정
- 경계 인터페이스인 Map을 Sensors 안으로 숨긴다. 따라서 Map인터페이스가 변하더라도 나머지 프로그램에는 영향을 미치지 않는다.
- Sensors 클래스는 프로그램에 필요한 인터페이스만 제공한다. 코드는 이해하기 쉽지만 오용하기는 어렵다. 설계 규칙과 비즈니스 규칙을 따르도록 강제할 수 있다.

✓ Map(혹은 유사한 경계 인터페이스들)을 쓸때마다 캡슐화하라는 소리가 아니다.
→ 여기저기 넘기지 말라는 의미
→ 이를 이용하는 클래스나 클래스 계열 밖으로 노출되지 않도록 주의
→ Map의 인스턴스를 공개 API의 인수로 넘기거나 반환값으로 사용하지 않는다.

###

### 경계 살피고 익히기

✓ 외부 패키지 테스트가 우리 책임은 아니다. 하지만 우리가 사용할 코드를 테스트하는 편이 바람직하다.

✓ 타사 라이브러리를 가져왔으나 사용법이 분명치 않은 경우

→ 몇 일 사용법을 고민하다가 우리쪽 코드를 작성해 라이브러리가 예상대로 동작하는지 확인. 우리 버그인지 라이브러리 버그인지 찾느라 오랜 디버깅하는 것 놀랍지도 않다.

→ 외부코드를 익히거나 통합하기는 힘들다. **곧바로 우리쪽 코드를 작성해 외부 코드를 호출하는 대신 먼저 간단한 테스트 케이스를 작성해 외부 코드 익히기 : 학습테스트**

→ 프로그램에서 사용하려는 방식대로 외부 API 호출

###

### log4j 익히기

✓ 147~149 log4j 학습테스트 과정

→ 간단한 콘솔 로거를 초기화하는 방법을 익혔으니, 이제 모든 지식을 독자적인 로거 클래스로 캡슐화한다. 그러면 나머지 프로그램은 log4j 경계 인터페이스를 몰라도 된다.

### 학습 테스트는 공짜 이상이다.

✓ 드는 비용이 없다. 투자하는 노력보다 성과가 더 크다.

✓ 패키지 새 버전이 나온다면 학습 테스트를 돌려 차이가 있는지 확인한다.

✓ 이런 경계 테스트가 있다면 패키지의 새 버전으로 이전하기 쉬워진다.
→ 낡은 버전 계속 쓰는 유혹에 빠지는 것을 피할 수 있음

### 아직 존재하지 않는 코드를 사용하기 (150~151p)

✓ 마틴형이 무선통신 시스템에 들어갈 소프트웨어 개발한 썰
→ 우리 세상과 저쪽 세상이 만나는 경계가 어디쯤인지 대략 감만 있었지만 그 너머는 모르는 상황
→ '송신기' 모듈에 원하는 기능은 식별 성공했으나 저쪽 팀이 API를 설계하지 않아 구현은 미루고 인터페이스 만듦
→ 어댑터 패턴으로 API 사용 캡슐화, API 바뀔 때 수정할 코드를 한곳으로 모음
→ FakeTransmitter 클래스를 사용하려 외부 클래스 테스트

✓ 우리가 바라는 인터페이스를 구현하면 우리가 인터페이스를 전적으로 통제한다는 장점이 생김. 가독성 증가, 의도 분명해짐

### 깨끗한 경계

✓ 경계에 위치하는 코드는 깔끔히 분리한다. 또한 기대치를 정의하는 테스트 케이스도 작성한다.

✓ 통제가 불가능한 외부 패키지에 의존하는 대신 통제가 가능한 우리 코드에 의존하는 편이 훨씬 좋다. 자칫하면 휘둘린다.

✓ 외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리하자.
→ Map에서 봤듯이, 새로운 클래스로 경계를 감싸기
→ ADAPTER 패턴을 사용해 우리가 원하는 인터페이스를 패키지가 제공하는 인터페이스로 변환

→ 가독성, 경계 인터페이스 사용 일관성, 외부 패키지 변경 시 코드 변경 소요 감소!