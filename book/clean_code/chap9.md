# CleanCode
# 9장 단위 테스트

### ❗️ 깨끗한 테스트 코드 유지하기
✓ 개발 속도를 명목으로 단위 테스트 규칙을 지키지 않은 팀. '지저분해도 빨리'

→ 지저분한 테스트 코드를 내놓으나 테스트를 안 하나... 오히려 더 못하다.

✓ 문제 : 실제 코드가 진화하면 테스트 코드도 변해야 한다.
→ 테스트 코드가 지저분할수록 변경이 어렵다.
→ 실제 코드 짜는 시간보다 테스트 코드 짜는 시간이 더 길어지고 부담이 된다.

✓ 새 버전 출시마다 테스트 비용이 늘어남. 불만 -> 테스트 슈트 폐기해야하는 상황

✓ 테스트 슈트 없이는 코드가 제대로 도는지 확인할 방법이 없음 -> 검증 불가 -> 결함율 상승 -> 코드 정리 안함 -> 망가짐

✓  **테스트 코드는 실제 코드 못지 않게 중요하다.** 이류 시민이 아니다.

🌱 테스트는 유연성, 유지보수성, 재사용성을 제공한다.

✓ 코드에 유연성, 유지보수성, 재사용성을 제공하는 버팀목이 바로 **단위 테스트**다.
→ 테스트 코드 없으면 모든 변경이 잠정적인 버그다.
→ 테스트 코드 커버리지가 높을수록 공포는 줄어든다

### ❗️ 깨끗한 테스트 코드

✓ 가독성, 가독성, 가독성

✓ 160-161p
→ 잡다하고 세세한코드를 다 없앰
→본론에 돌입해 진짜 필요한 자료 유형과 함수만 사용한다.
→ 읽는 사람이 헷갈릴 필요가 없이 빨리 기능을 이해

🌱 도메인에 특화된 테스트 언어

✓ 목록 9-2는 도메인에 특화된 언어(DSL)로 테스트 코드를 구현하는 기법을 보여준다. 흔히 쓰는 시스템 조작 API를 사용하는 대신 API 위에다 함수와 유틸리티를 구현한 후 그 함수와 유틸리티를 사용하므로 테스트 코드를 짜기도 읽기도 쉬워진다.

→ 테스트 코드에서 사용하는 특수 API가 됨
→ 당사자와 나중에 테스트를 읽어볼 독자를 도와주는 테스트 언어

🌱 이중 표준(162p~)

✓ 목록 9-3을 변경 -> (목록 9-4, 9-5)
→ 대문자를 on, 소문자를 off로 약속하여 테스트 코드를 읽기 쉽게 만듦.

✓ 목록 9-6 getState() StringBuffer대신 += 사용하여 문자열 합침
→ StringBuffer는 보기 흄함. 테스트 환경은 자원이 제한적일 가능성이 낮다.

→ 이중 표준의 본질. 실제 환경에서는 절대로 안 되지만 테스트 환경에서는 문제가 없다. 대개 메모리나 CPU 효율과 관련 있는 경우며 코드이 깨끗함과는 철저히 무관하다.

### ❗️테스트 당 assert 하나

✓ 테스트 코드를 짤 때, assert 문을 함수마다 하나만 사용해야 한다고 주장하는 학파가 있다.

✓ 테스트를 분리하면 중복되는 코드가 생긴다.
→ TEMPLATE METHOD 패턴을 사용함녀 중복을 제거할 수 있다. 하지만 모두 배보다 배꼽이 더 크다.
→ 이것저것 감안해 보면 결국 목록 9-2처럼 여러개 사용하는게 좋다고 생각한다.

✓ 최대한 assert 문 줄이려고 노력하기

→ 결국엔 마틴형도 좋은 지침이라 생각한다. 단일 assert를 지원하는 해당 분야 테스트 언어를 만들려 노력한다. 하지만 때로는 주저 없이 함수하나에 여러 assert문 넣기도 한다.

🌱 테스트 당 개념 하나

✓ 목록 9-8에서 달력 관련되어 테스트 메서드 3개가 같이 있지만, 자세히 보면 다른 개념을 측정한다.

✓ 목록 9-8은 assert문이 여러개인게 문제가 아니다. 여러 개념을 테스트 하고 있는게 문제다.

✓ 개념 당 assert 문 수를 최소로 줄여라. 테스트 함수 하나는 개념 하나만 테스트하라

### F.I.R.S.T

✓ 깨끗한 테스트는 다음 다섯 가지 규칙을 따른다.

    1.  빠르게(Fast)
→ 테스트는 빨라야 한다.
→ 느리면 자주 돌릴 엄두를 못낸다. 자주 안 돌리면 초반 문제를 찾아내 고치지 못한다.
→ 코드를 마음껏 정리도 못한다. 품질 망가진다.

    1.  독립적으로(Independent)
→ 각 테스트는 서로 의존하면 안된다.
→ 독립적으로 어느 순서로 실행해도 괜찮아야 한다.
→ 서로 의존하면 하나가 실패할 때 잇달아 실패. 원인 진단이 어려워짐. 결함 숨음

    1.  반복가능하게(Repeatable)
→ 어떤 환경에서도 반복 가능해야 한다.
→ 버스타고 집가는길에 네트워크 없이도 돼야함.
→ 테스트가 돌아가지 않는 환경이 있다면 실패한 이유를 둘러댈 변명이 생긴다.
→ 환경이 지원되지 않아 못돌리는 상황
    1. 자가검증하는(Self-Validating)
→ 부울(bool)값으로 결과를 내야 한다. 성공 아니면 실패다.
→ 통과 여부를 알려고 로그 파일을 읽게 만들어서는 안 된다. 텍스트 파일 두 개를 수작업으로 비교하게 만들어서도 안 된다.
→ 테스트가 스스로 성공과 실패를 가늠하지 않으면 판단은 주관적이 되며 지루한 수작업 평가가 요구된다.
    1. 적시에(Timely)
→ 적시에 작성해야 한다.
→ 실제 코드를 구현하기 직전에 구현한다.
→ 실제 코드부터 구현하면, 실제 코드가 테스트 하기 어렵다거나 테스트가 불가능하도록 설계할지도 모른다.

### 결론

✓ 테스트 코드는 실제 코드만큼이나 프로젝트 건강에 중요하다.

✓ 지속적으로 깨끗하게 테스트 코드 관리하기
→ 표현력 높이고 간결하게 정리
→ 도메인 특화 언어 만들기