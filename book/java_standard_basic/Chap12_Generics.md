지네릭스, 열거형, 애너테이션
========
# 1. 지네릭스(Generics)
## 1.1. 설명
- 컴파일 시의 타입 체크를 해주는 기능
- **타입의 안정성을 제공**
- **타입체크**와 **형변환**을 생략 가능 -> 코드가 간결해짐
- 형변환 생략 ? : 원래는 Object형으로 반환되던거 바꿔주니 안해도 됨
## 1.2. 타입변수
- ArrayList클래스의 선언에서 클래스 이름 옆의 '<>'안에 있는 E를  '타입 변수'라고 하며, 일반적으로는 'Type'의 첫 글자를 따서 T를 사용
- ArrayList<E>의 경우 Element 첫 글자
- 타입 변수가 여러 개인 경우 Map<K,V>와 같이 ','를 구분자로 나열
```
//제네릭스 도입 전
public class ArrayList extends AbstractList{
    private transient Object[] elementData{~};
    public boolean add(Object o){~};
    public Object get(int index){~};
    ...
}
// 도입 후
public class ArrayList<E> extends AbstractList<E>{
    private transient E[] elementData{~};
    public boolean and(E o){~};
    public E get(int index){~};
    ...
}
```
- E 자리에 자료형을 넣으면 모두 대입되어 들어간다고 생각하면 편함. 형변환 불필요
## 1.3. 용어
- 지네릭 타입 호출 : 타입 매개변수를 지정하는 것
- 매개변수화된 타입 : 지정된 타입
- Box<String>과 Box<Integer>는 지네릭 클래스 Box<T>에 서로 다른 타입을 대입하여 호출한 것일 뿐, 이 둘이 별개의 클래스를 의미하는 것은 아니다. **컴파일 후에** Box<String>과 Box<Integer>는 이들의 '원시 타입'인 Box로 바뀐다. 즉 지네릭 타입이 제거된다.
## 1.4. 다형성
- **참조변수에 지정해둔 지네릭 타입**과 **생성자에 지정해 준 지네릭 타입**은 **일치해야 한다.** 두 클래스가 서로 상속관계에 있어도 일치해야한다.
- 지네릭 타입이 **아닌 클래스간 다형성**은 괜찮다.
- 지네릭 타입이 상위 클래스인 ArrayList를 생성하고, 이 ArrayList에 해당 클래스의 자손을 저장하는건 가능하다. 단, 꺼낼때 형변환이 필요하다.

## 1.5. Iterator<E>
- 제네릭스가 도입되면서 기존의 소스에 Object가 들어간 클래스는 거의 바뀌었다고 보면 됨
## 1.6. HashMap<K,V>
- 지정해야 할 타입이 두개, 콤마로 타입을 구분
- K, V는 임의의 참조형 타입을 의미
- 마찬가지로 get(Object key), keySet()/values() 사용 시 형변환 안해도 됨

## 1.7. 제한된 지네릭 클래스
- 지네릭 타입에 'extends' 사용 시 특정 타입의 자손들만 대입할 수 있게 제한할 수 있다.
- 주의할 점은 여전히 **한 종류**만 담을 수 있다. 하지만 자손들만 담을 수 있다는 제약이 하나 더 추가된 것이다.
- 클래스가 아닌 **인터페이스를 구현**해야 한다면 이때도 extends사용(implement(x))
```
//Fruit의 자손이면서 Eatable인터페이스도 구현해야 한다면?
class FruitBox<T extends Fruit & Eatable>{...}
```
## 1.8. 지네릭스의 제약
    1. static멤버에 타입 변수 T를 사용 불가 : T는 인스턴스 변수로 간주, 때문에 모든 객체에 동일하게 동작해야하는 static멤버는 인스턴스 변수 참조 불가 
    -> 생성할때 생각해보면 맞는 얘기
    ‣ 객체별로 다른 타입을 지정하는 것은 적절하다. 제네릭스는 인스턴스별로 다르게 동작하도록 만든 기능이다.
    2. 제네릭 타입의 배열 생성 x 참조 변수 선언은 가능: new, instanceof에 피연산자로 T 사용 불가
    -> new 연산자는 컴파일 시점에 T가 뭔지 정확히 알아야 하는데 그것을 알 방법이 없음(468)
## 1.9. 와일드 카드
- 제네릭 타입에 다형성을 적용할 방법은 없을까? -> 와일드 카드
<? extends T> 와일드 카드 상한 제한. T와 그 자손들만 가능 
<? super T> 와일드 카드 하한 제한, T와 그 조상들만 가능
<?> : 제한 없음. 모든 타입이 가능. <? extends Object>와 동일
- 다형성이용 생성할때, 매개변수로 받을 때
## 1.10. 지네릭 메서드
- 선언부에 지네릭 타입이 선언된 메서드
- ex) Collection.sort()
```
static <T> void sort(List<T> list, Comparator<? super T> c)
```
- 지네릭 클래스가 아닌 클래스에도 정의될 수 있다.
- 주의! 지네릭 **클래스에 정의된** 타입 매개변수 **T**와 **매개변수에 정의된** 타입 매개변수 **T**는 다르다.
- static**멤버**에는 타입 매개변수를 사용할 수 없지만, **메서드**에 지네릭 타입을 선언하고 사용하는 것은 가능하다.
- 메서드에 선언된 지네릭 타입은 **메서드 내에서만 지역적으로 사용**될 것이므로 메서드가 static이건 아니건 상관 없음
+ 호출 시 Juicer.<Fruit>makeJuice(fruitBox)와 같이 타입 변수에 타입 대입해서 호출
+ 생략해도 컴파일러가 선언부를 통해 추정해준다.
+ 대입 타입 생략 불가 시 참조변수나 클래스 이름을 생략할 수 없다.
## 1.11. 지네릭 타입 형변환
- (지네릭 - 넌지네릭)원시 타입과 지네릭 타입은 서로 형변환이 가능하나 경고가 뜸
- (지네릭 - 지네릭)Object, String 등 서로 형변환 불가
```
//error
Box<Object> objBox = (Box<Object>)new Box<String>();

//ok
Box<? extends Object> wBox = new Box<String>();
```
- 형변환, 다형성을 위해 와일드카드를 써야함.
## 1.12. 지네릭 타입의 제거
- 컴파일러는 지네릭 타입을 이용해 소스파일을 체크, 필요한 곳에 형변환을 넣어준다. 그리고 지네릭 타입을 제거한다. -> 클래스파일에 지네릭 타입 정보 없음(이전 버전 호환)  

      1. 지네릭 타입의 경계(bound)를 제거
      2. 지네릭 타입 제거 후에 타입 일치하지 않으면 형변환을 추가
        - List의 get()은 Object타입을 반환하므로 형변환 필요
        - 와일드 카드가 포함되어 있는 경우 적절한 타입으로의 형변환 추가
***
# 2. 열거형


### 의문
리스트에 다양한 자식 클래스들 처리도 컴파일러가 각각 해주는건지?