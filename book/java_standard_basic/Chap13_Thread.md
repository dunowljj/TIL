쓰레드
========
# 1. 프로세스 vs 쓰레드
## 1.1. 프로세스
- 실행 중인 프로그램
- 프로그램 실행하면 OS로부터 실행에 필요한 자원을 할당받아 프로세스가 됨
## 1.2. 쓰레드
- 프로세스의 자원을 이용해서 실제로 작업을 수행
- 프로세스 당 최소한 하나 이상의 쓰레드 존재
- 멀티쓰레드 프로세스 : 둘 이상의 쓰레드를 가진 프로세스
## 1.3. 멀티쓰레딩의 장단점
- DOS같은 OS는 한 번에 한 가지 작업만 가능, 윈도우 등은 (멀티태스킹 가능) 동시에 여러 작업 수행 가능
- 여러 사용자에게 서비스 시 필수
    - 멀티쓰레드 사용을 안하면 사용자의 요청마다 새로운 프로세스를 생성해야 -> 쓰레드에 비해 더 많은 시간과 메모리 공간 필요
- 쓰레드를 경량 프로세스(LWP, light-weight process)라고 부르기도 함
### 1.3.1. 장점 
- CPU 사용률 향상
- 자원을 보다 효율적으로 사용
- **사용자에 대한 응답성**이 향상
- 작업이 분리되어 코드가 간결해짐
### 1.3.2. 단점
- 여러 쓰레드가 같은 프로세스 내에서 자원을 공유하면서 작업하기 때문에 **동기화(synchronizeation)**, **교착상태(deadlock)**와 같은 문제들을 고려해서 신중히 프로그래밍해야 한다.
***

# 2. 쓰레드의 구현과 실행
## 2.1. 구현
    1. Thread클래스 상속받기
    2. Runnable인터페이스 구현하기
- 어느 쪽을 선택해도 별 차이는 없지만 Thread 상속 시 다른 클래스를 상속받을 수 없어서 보통 Runnable 구현이 일반적
- Runnable인터페이스 구현이 재사용성이 높고 코드의 일관성을 유지
### Runnable인터페이스
- 오로지 run()만 정의된 인터페이스
- run() 몸통만 만들어주면 됨
- Thread클래스도 run만 채우면 됨
## 2.2. 생성
```
//Thread 자손 클래스 인스턴스 생성
ThreadEx1_1 t1 = new ThreadEx1_1();

//Runnable 구현 후 생성
Runnable r = new ThreadEx1_2();
Thread t2 = new Thread(r);

//Runnable 한줄로 줄임
Thread t2 = new Thread(new ThreadEx1_2);
```
- static thread currentThread() : 현재 실행중인 쓰레드의 참조를 반환
- String getName() : 쓰레드의 이름을 반환
## 2.3. 실행
- start()를 호출해야만 쓰레드가 실행된다.
- 호출해도 일단 실행대기 상태에 있다가 자기 차례가 되어야 실행한다.
- 쓰레드의 실행 순서는 OS의 스케쥴러에 의해 결정
- 주의: 한 번 실행이 종료된 쓰레드는 다시 실행할 수 없다.(하나의 쓰레드에 하나의 start()) -> 두 번 호출 시 IllegalThreadStateException
## 2.4. start() 와 run() (511p)
- run() : 생성된 쓰레드를 실행시키는 것이 아니라 단순히 클래스에 선언된 메서드를 호출
- start() : 쓰레드가 작업하는데 필요한 호출스택을 생성한 다음에 run()을 호출해서, 생성된 호출스택에 run()이 첫 번째로 올라가게 한다.
## 2.5. main쓰레드 
- main메서드의 작업을 수행하는 것도 쓰레드이다.
- 실행 중인 사용자가 쓰레드가 하나도 없을 때 프로그램은 종료된다.
***
# 3. 싱글쓰레드와 멀티쓰레드
## 3.1. 싱글코어일 때 두 개의 작업 처리
    1. 싱글쓰레드 : 한 작업을 마친 후에 다른 작업 시작
    2. 멀티쓰레드(2개) : 짧은 시간동안 2개의 쓰레드가 번갈아 가면서 작업을 수행해서 동시에 두 작업이 처리되는 것과 같이 느끼게 함
- 처리되는 시간은 거의 같고, 작업 전환때문에 멀티쓰레드가 더 오래 걸림
    - cf)프로세스의 스위칭이 더 오래걸림
- 싱글 코어에서 단순히 CPU만을 사용하는 계산작업이라면 오히려 싱글쓰레드가 효율적이다.
## 3.2. 싱글코어, 멀티코어 일때 소요 시간 출력
- 한 쓰레드가 화면에 출력하고 있는 동안 다른 쓰레드는 출력이 끝나기를 기다려야함(대기시간 발생) -> 화면(console)이라는 자원을 두고 두 쓰레드가 경재 
- 쓰레드의 불확실성
    - JVM의 쓰레드 스케줄러에 의해서 실행순서와 실행시간 결정
    - 프로세스도 프로세스 스케줄러에 의해서 실행순서와 실행 시간이 결정
    - 매 순간에 따라 할당되는 시간이 쓰레드, 프로세스 모두 일정하지 않음
- 자바가 OS 독립적이지 못한 부분중 하나가 쓰레드이다.
***
# 4. 쓰레드의 I/O블락킹
- 쓰레드가 입출력(I/O)처리를 위해 기다리는 것
- 두 쓰레드가 서로 다른 자원을 사용하는 작업의 경우 멀티쓰레드 프로세스가 더 효율적
- 입력을 기다리는 동안 다른 쓰레드 작업을 처리 -> CPU 사용에 효율 상승!
***

# 5. 쓰레드의 우선순위
- 쓰레드는 우선순위라는 속성(멤버변수)을 가지고 있다
- 우선순위 값에 따라 쓰레드가 얻는 실행시간이 달라짐
- 특정 쓰레드가 더 많은 작업시간을 갖도록 할 수 있음
    - 파일전송기능이 있는 메신저
        - 채팅 기능이 파일 전송기능보다 우선시, 대신 파일 전송이 더 걸림
    - 시각적인 뿐이나 사용자에게 빠르게 반응해야하는 작업을 하는 쓰레드의 우선순위가 높아야 함
### 스레드의 우선순위 지정하기
```
void setPriority(int newPriority)
int getPriority()

public static final int MAX_PRIORITY = 10 //최대우선순위
public static final int MIN_PRIORITY = 1  //최소우선순위
public static final int NORM_PRIORITY = 5 //보통우선순위
```
- 1~10 숫자가 높을수록 우선순위가 높다.
- 생성한 쓰레드로부터 상속받는다.
    - main메서드를 수행하는 쓰레드는 우선순위가 5, main 메서드 내에서 생성하는 쓰레드의 우선순위는 자동으로 5가 됨.
- 쓰레드를 실행하기 전에만 우선순위를 변경할 수 있다.
+ 멀티코어에서는 쓰레드의 우선순위에 따른 차이가 거의 없었다.
    - 어떤 OS냐에 따라 다른 결과를 얻을 수 있고, 굳이 우선순위에 차등을 두려면 특정 OS의 스케쥴링 정책과 JVM구현을 직접 확인해봐야 한다.
***

# 6. 쓰레드 그룹
## 6.1. 개념
- 서로 관련된 쓰레드를 그룹으로 다루기 위한 것
- 폴더에 관련된 파일을 넣듯이 쓰레드를 그룹으로 묶어서 관리
- 그룹안에 그룹 가능
- 보안상의 목적
    - 자신이 속한 쓰레드 그룹이나 하위 쓰레드 그룹은 변경할 수 있으나 다른 쓰레드 그룹의 쓰레드는 변경 불가
- 모든 쓰레드는 쓰레드 그룹에 포함되어 있어야 함
## 6.2. 생성
```
Thread(ThreadGroup group, String name)
Thread(ThreadGroup group, Runnable target)
Thread(ThreadGroup group, Runnable target, String name)
Thread(ThreadGroup group, Runnable target, String name, long stackSize)
```
- Thread 생성자 이용
- 위와 같이 그룹을 지정하지 않고 생성한 쓰레드는 기본적으로 자신을 생성한 쓰레드와 같은 쓰레드 그룹에 속하게 된다.
- 자바 어플리케이션이 실행되면, JVM은 main과 system이라는 쓰레드 그룹을 만들고 JVM 운영에 필요한 쓰레드들을 생성해서 이 그룹들에 포함
    - main쓰레드 그룹 : main쓰레드
    - system쓰레드 그룹 : Finalizer쓰레드
- 우리가 생성하는 모든 쓰레드 그룹은 **main쓰레드 그룹**의 **하위 쓰레드 그룹**이다.
## 6.3. 메서드
- ThreadGroup getThreadGroup() : 쓰레드 자신이 속한 쓰레드 그룹을 반환한다.
- void uncaughtException(Thread t, Throwable e) : 처리되지 않은 예외에 의해 그룹의 쓰레드가 실행이 종료되었을 때, JVM에 의해 이 메서드가 자동 호출
- 524p 참조
***

# 7. 데몬 쓰레드
## 7.1. 개념
- 다른 일반 쓰레드의 작업을 돕는 보조적인 역할
- 일반 쓰레드 모두 종료 시 데몬 쓰레드는 강제적으로 자동 종료
    - 이 점을 제외하면 일반쓰레드와 다를게 없음.
- ex) 가비지 컬렉터, 워드프로세서의 자동저장, 화면자동갱신
## 7.2. 사용
- 일반 쓰레드와 작성과 실행이 같음
- 쓰레드를 생성 후 실행 전에 setDemon(true)를 호출하기만 하면 된다.
- 데몬 쓰레드가 생성한 쓰레드는 자동으로 데몬 쓰레드가 된다.
- boolean isDaemon() : 쓰레드가 데몬 쓰레드인지 확인, 데몬 쓰레드이면 true
- void setDaemon(boolean on) : 쓰레드를 데몬 쓰레드로 또는 사용자 쓰레드로 변경. on 값을 true로 지정 시 데몬 쓰레드가 됨
## 7.3. 예제 
- (526p)오토세이브 기능을 데몬쓰레드로 지정
- 데몬쓰레드로 설정하지 않았다면 강제종료하지 않는 한 영원히 종료되지 않았다.
***

# 8. 쓰레드의 상태
- 생성된 후부터 종료될 때가지 여러 상태를 가질 수 있다.
    - NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED
- 527p 그림 및 과정 암기

# 9. 쓰레드의 실행제어
## 9.1. 필요
- 쓰레드 프로그래밍이 어려운 이유 : 동기화, 스케줄링
- 정교한 스케줄링을 통해 주어진 자원과 시간을 쓰레드가 낭비없이 잘 사용하도록 프로그래밍 해야 한다.
- 상태 관련 메서드 잘 알아야 함.
## 9.2. 스케줄링 관련된 메서드
- static oid sleep(long millis)/(long millis, int nanos) : 지정된 시간 동안 쓰레드를 일시정지. 지정 시간 지나면 자동적으로 실행대기상태가 된다.
- void join()/(long millis)/(long millis, int nanos) : 지정된 시간동안 쓰레드가 실행되도록 한다. 지정 시간이 지나거나 작업이 종료되면 join()을 호출한 쓰레드로 다시 돌아와 실행을 계속
- void interrupt() : sleep()이나 join()에 의해 일시정지상태인 쓰레드를 깨워서 실행대기상태로 만듦. 해당 쓰레드에서는 Interrupted Exception이 발생함으로써 일시정지상태를 벗어남
- void stop() : 쓰레드를 즉시 종료
- void suspend() : 쓰레드를 일시정지시킨다. resume()을 호출하면 실행대기상태가 된다.
- void resume() : suspend()에 의해 일시정지상태에 있는 쓰레드를 실행대기상태로 만든다.
- static void yield() : 실행 중에 자신에게 주어진 실행시간을 다른 쓰레드에게 양보하고 자신은 실행대기상태가 된다.
### 9.2.1. sleep()
- 지정된 시간동안 쓰레드 멈춤
```
static void sleep(long millis)
static void sleep(long millis, int nanos)
```
- 나노세컨드
    - 범위 : 0~999999
    - 999999나노세컨드 = 약 1밀리세컨드
- 일시정지 상태에서 interrupt()가 호출되면, InterruptedException이 발생되어 실행대기 -> 항상 try-catch문으로 예외처리 해줘야 함
- try-catch문까지 포함하는 새로운 메서드 만들기도 함
    - void delay(long milis)...
### 9.2.2. interrupt()
- 진행 중인 쓰레드의 작업이 끝나기 전에 취소해야할 경우
    - 큰 파일 다운 시 너무 오래걸려서 중간에 포기하고 취소
- 단지 멈추라고 요청하는 것 뿐 쓰레드 강제 종료는 불가능
- 쓰레드의 interrupted상태(인스턴스 변수)를 바꾸는 것 뿐
- interrupted : 호출되었다면 true, 호출되지 않았다면 false
    - interrupt()가 호출되면 interrupted()의 결과가 false에서 true로 바뀌어 while문을 벗어나게 된다.
    - isinterrupted()는 상태만 반환, interrupted는 반환 후, false로 변경
```
void interrupt() 쓰레드의 interrupted상태를 false에서 true로 변경
boolean isInterrupted() 쓰레드의 interrupted상태를 반환
static boolean interrupted() 현재 쓰레드의 interrupted상태를 반환 후, false로 변경
```
- sleep, wait, join에 의해 일시정지 상태에 있을 때, 호출하면 실행대기 상태로 바뀜
### 9.2.3. suspend(), resume(), stop()
- suspend()로 정지된 쓰레드는 resume()을 호출해야 다시 실행대기가 된다.
- stop()은 호출 즉시 쓰레드가 종료된다.
- suspend()와 stop()이 교착상태를 일으키기 쉽게 작성되어 있어 이 메서드들 모두 **deprecated** 되었다.
### 9.2.4. join()과 yield()
#### join()
- 다른 쓰레드 작업을 기다린다.
- 시간을 지정하지 않으면, 해당 쓰레드가 작업을 모두 마칠 때까지 기다리게 된다.
- sleep()과 같이 try-catch문으로 감싸야 한다.
- join은 현재 쓰레드가 아닌 특정 쓰레드에 대해 동작하므로 static메서드가 아니다.
#### yield()
- 다른 쓰레드에게 양보한다.
- 자신에게 주어진 실행시간을 다음 차례의 쓰레드에게 양보한다.

# 10. 쓰레드의 동기화
## 10.1. 동기화
- 멀티쓰레드 프로세스의 경우 여러 쓰레드가 같은 프로세스 내의 자원을 공유해서 작업
-> 작업 도중 제어권을 넘겨주고 다시 받아서 작업을 마쳤을 때 의도와 다른 결과가 나올수도 있다.
- 한 쓰레드가 특정 작업을 끝마치기 전까지 다른 쓰레드에 의해 방해받지 않도록 하기 위한 개념 : 임계 영역(critical section), 잠금(lock)  
    
      1. 공유 데이터를 사용하는 코드 영역을 임계 영역으로 지정
      2. 공유 데이터(객체)가 가지고 있는 lock을 획득한 단 하나의 쓰레드만 이 영역 내의 코드를 수행 가능
      3. 해당 스레드가 임계 영역 내의 모든 코드를 수행하고 벗어나서 lock을 반납해야만 다른 쓰레드가 반납된 lock을 획득하여 임계 영역의 코드를 수행할 수 있게 됨
      => **한 쓰레드가 진행 중인 작업을 다른 쓰레드가 간섭하지 못하도록 막는 것을 '쓰레드의 동기화(synchronization)라고 한다.**
- synchronized블럭을 이용해서 쓰레드의 동기화 지원
- JDK1.5부터는 java.util.concurrent.locks, java.util.concurrent.atomic 패키지를 통해 다양한 방식의 동기화 구현 지원
## 10.2 synchronized를 이용한 동기화
### 10.2.1. 메서드 전체를 임계 영역으로 지정
```
public synchronized void calcSum(){
    //...
}
```
- 메서드 앞에 `synchronized` 붙이기
- 메서드 전체가 임계 영역으로 설정
- 메서드가 호출된 시점부터 해당 메서드가 포함된 객체의 lock을 얻어 작업을 수행하다가 메서드가 종료되면 lock을 반환
### 10.2.2. 특정한 영역을 임계 영역으로 지정
```
synchronized(객체의 참조변수){
    .../
}
```
- 메서드 내의 코드 일부를 블럭{}으로 감싸고 블럭 앞에 `'synchronized(참조변수)'` 붙이기
- 참조변수는 락을 걸고자하는 객체를 참조하는 것이어야 한다.
- 해당 블럭을 `synchronized블럭`이라고 부르며, 이 블럭 영역 안으로 들어가면서부터 쓰레드는 지정된 객체의 lock을 얻게 되고, 벗어나면 반납
###
- 두 방법 모두 lock의 획득과 반납이 모두 자동적으로 이루어지므로 우리가 해야 할 일은 그저 임계 영역만 설정
- 모든 객체 lock 가짐. lock을 가진 쓰레드만 임계 영역 코드 수행 가능
- 임계 영역은 멀티쓰레드 프로그램 성능을 좌우. 가능하면 메서드 전체에 락보다 `syncronized블럭`으로 임계영역을 최소화하여 효율을 얻어야
- 540p의 경우 balance의 접근 제어자를 private으로 해줘야 한다. 아니면 외부에서 직접 접근해서 동기화해도 의미가 없다. -?
## 10.3. wait(), notify(), notifyAll()
- 특정 쓰레드가 객체의 락을 가진 상태로 오랜 시간 보내지 않는 것도 중요
    - 계좌에 출금할 돈이 없어서 한 쓰레드가 락을 보유한 채로 입금까지 오래 기다린다면?
- 특정 객체에 대한 것이므로 Object클래스에 정의되어 있음
- `동기화 블록(synchronized블록)`내에서만 사용할 수 있다.
- 보다 효율적 동기화 가능
### 10.3.1. wait()
- 쓰레드가 락을 반납하고 기다리게 함
- **notify()호출**까지 기다림, 매개변수가 있는 wait()은 **지정된 시간동안**만 기다림
- 실행 중이던 쓰레드는 해당 객체의 `대기실(waitng pool)`에서 통지를 기다림
- 동기화된 임계 영역의 코드를 수행하다가 작업을 더 이상 진행할 상황이 아닐때 사용 후
### 10.3.2. notify()
- 나중에 작업을 진행할 수 있는 상황이 되면 notify()를 호출
- 해당 객체의 대기실에 있던 모든 쓰레드 중에서 **임의의 쓰레드**만 통지를 받는다.
### 10.3.3. notifyAll()
- 기다리는 **모든 쓰레드**에게 통보를 한다. lock을 얻는건 **하나** 뿐
- 깨워지는 것은 모든 객체가 아닌 **호출된 객체**의 대기 중인 쓰레드만 해당한다.

### 예제
- 특히 542~ 다시보기
