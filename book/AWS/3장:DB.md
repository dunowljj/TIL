스프링 부트에서 JPA로 데이터베이스 다뤄보자
===========
MyBatis, iBatis는 ORM(객체 매핑)이 아닌 SQL Mapper(쿼리 매핑)이다.
# 3.1 JPA 소개
## 3.1.1. 패러다임 불일치
- RDB는 현대 웹 어플리케이션에서 필수적인 요소 -> 문제 : SQL밖에 인식할 수 없음
- 패러다임의 불일치
    - 관계형 데이터베이스 : 어떻게 데이터를 저장할지
    - 객체지향 프로그래밍 언어 : 기능과 속성을 한 곳에서 관리하는 기술
+ JPA는 중간에서 패러다임을 일치시켜줌 
    + 객체지향적 프로그래밍을 하고, JPA가 관계형 데이터베이스에 맞게 SQL
    + SQL 종속적 개발에서 탈피
    + 생산성 향상, 유지보수의 편의성
## 3.1.2. Spring Data JPA 소개
- JPA : 인터페이스로서 자바 표준명세서
- 대표적인 구현체 : Hibernate, Eclipse Link

        JPA <- Hiberbate <- Spring Data JPA

- Hibernate와 큰 차이 없으나 Spring Data JPA 모듈 권장 이유  
    - 구현체 교체의 용이성 : 쉽게 다른 구현체로 교체
    - 저장소 교체의 용이성 : 관계형 DB외에 다른 저장소로 쉽게 교체  
    -> 의존성만 교체하면 해결(하위 프로젝트들은 기본적인 CRUD의 인터페이스가 일치)
## 3.1.3. 실무에서 JPA
- 높은 러닝 커브 : RDB, OOP 모두 이해해야함
- 네이티브 쿼리만큼의 퍼포먼스를 낼 수 있는 자료들
## 3.1.4. 요구사항 분석
***

# 3.2. 프로젝트에 Spring Data JPA 적용하기
## 3.2.1. build.gradle
- spring-boot-starter-data-jpa
- h2
    - 인메모리 관계형 데이터베이스
    - 별도 설치없이 프로젝트 의존성만으로 관리
    - 메모리 실행, 어플리케이션 재시작 시 초기화
## 3.2.2. domain 패키지 생성
>도메인 참고 도서 : <DDD Start, 최범균님>
## 3.2.3. 어노테이션 
- 작성자는 주요 어노테이션을 클래스에 가깝게 둠 -> 코틀린 등 새 언어로 전환으로 롬복이 필요없을 경우 삭제 편리
- @Entity
    - 테이블과 링크될 클래스
    - 클래스의 카멜케이스이름 -> 언더스코어 네이밍으로 테이블 이름 매칭
- @Id
    - 해당 테이블의 PK필드
- @GeneratedValue
    - PK의 생성 규칙을 나타냄
    - GenerationType.IDENTITY : 2.0부터 추가해야 auto_increment 됨
- @Column
    - 테이블의 칼럼
    - 굳이 선언안해도 되지만, 기본값 외에 추가로 변경이 필요한 옵션이 있을 시 사용
    - 문자열 디폴트 VARCHAR(255) 사이즈를 바꿀때, 타입을 TEXT로 변경 등
    
>auto_increment, 스프링 부트 2.0버전과 1.5버전의 차이 https://jojoldu.tistory.com/295  
>책 91p auto_increment 추천하는 이유

- @Builder(lombok)
    - 해당 클래스의 빌더 패턴 클래스를 생서 
    - 생성자의 상단에 선언 시 생성자에 포함된 필드만 빌더에 포함
    -> 롬복 어노테이션들이 빈번하게 변경되는 설계에서 변경량을 최소화해줌
    - 어느 필드에 어떤 값을 채워야할지 명확한 인지 가능
- @Getter, Setter
    - 무분별한 사용 x -> 값이 어디서 변하는지 구분 힘듦
    - Entity 클래스에 Setter 절대 x, 여기선 빌더 사용
## 3.2.4. JpaRepository 생성
- MyBatis의 Dao라고 불리는 DB Layer 접근자
- 인터페이스 생성 후, JpaRepository<Entity 클래스, PK 타입> 상속, 기본 CRUD 메서드 사용 가능
- Entity 클래스와 Entity Repository 함께 위치해야 함
***

# 3.3. 테스트 코드 작성하기
## 3.3.4. 어노테이션
- @After
    - Junit에서 단위테스트가 끝날 때마다 수행되는 메소드를 지정 
    - 보통은 배포 전 전체 테스트를 수행할 때 테스트간 데이터 침범을 막는 용도
    - 여러 테스트 동시 수행 시 데이터가 남아 다음 테스트 실패할 수 있음
- @postsRepository.save
    - 테이블 posts에 insert/update 쿼리 실행
    - 값이 있으면 update, 없으면 insert
- @postsRepository.findAll
    - 모든 데이터 조회
## 3.3.5. 실제 쿼리 확인 방법
    1. resources/application.properties 생성
    2. spring.jpa.show_sql=true 입력
    3. id bigint generated by default as identity -> id bigint not null auto_increment 변경하기
    (spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect 추가)
***

# 3.4. 등록/수정/조회 API만들기
## 3.4.1. spring web 계층
- Web Layer, Service Layer, Repository Layer, DTOs, Domain Model
- Service는 트랜잭션, 도메인 간 순서 보장 역할 -> 비지니스 로직 x
- 비지니스 로직은 Domain에서 담당
- 기존 서비스로 처리하던 방식을 사용 : 객체는 단순한 데이터 덩어리 역할만 하게 됨
- 도메인 모델을 사용 : 각 객체가 이벤트를 처리, 서비스 메소드는 트랜잭션의 도메인 간의 순서만 보장
- @RequierdArgsConstructor
- Entity 클래스를 Request/Response 클래스로 사용 x; View Layer, DB Layer 분리
## 3.4.2. Api ControllerTest 
- @SpringBootTest와 TestRestTemplate 사용 : JPA기능까지 테스트할때 사용
- @WebMvcTest : JPA 기능이 작동하지 않음, 외부 연동과 관련된 부분(Controller, ControllerAdvice등)만 활성화
- @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
- @LocalServerPort
## 3.4.3. JPA 영속성 컨텍스트와 더티 체킹
- JPA 엔티티 매니저 활성화 상태로 트랜잭션 안에서 데이터베이스에서 데이터를 가져오면 이 데이터는 영속성 컨텍스트가 유지된 상태
- 이 상태에서 해당 데이터 변경 시 트랜잭션이 끝나는 시점 반영 -> 별도로 Update 쿼리를 날릴 필요가 없음
>이동욱님 블로그 더티 체킹  
https://jojoldu.tistory.com/415

## 3.4.4. h2 console 활용
    1. application.properties에 spring.h2.console.enabled=true 추가
    2. main 실행
    3. http://localhost:8080/h2-console 접속
    4. JDBC URL에 jdbc:h2:mem 입력, connect
***

# 3.5. JPA Auditing으로 생성시간/수정시간 자동화하기
- 보통 엔티티는 해당 데이터의 생성시간과 수정시간 포함
- 매번 DB에 생기는 반복적인 코드를 해결
## 3.5.1. LocalDate 사용
- 기존 Date의 문제점을 고친 타입으로 Java8부터 도입
>java8 이전의 Date와 Calendar클래스의 문제점(120p)
## 3.5.2. Auditing 사용    
    1. BaseTimeEntity클래스 생성
        - @MappedSuperclass
        - @EntityListeners(AuditingEntityListener.class)
        - @CreatedDate
    2. Posts클래스 BaseTimeEntity 상속
    3. Application 클래스 @EnableJpaAuditing


